// Domain
border a(t = -1,1){x = -1; y = - t; label = 1;}
border b(t = -1,1){x = t; y = -1; label = 2;}
border c(t = -1,1){x = 1; y = t; label = 3;}
border d(t = -1,1){x = - t; y = 1; label = 4;}

// mesh
mesh Th = buildmesh(a(67) + b(67) + c(67) + d(67));
plot(Th);

fespace Xh(Th,P1);

// read the matrix
ifstream AField("Matrix.txt");
// Read matrix size and grid stepsize (store in file)
int s;
real dA;
AField >> s;
AField >> dA;
real[int,int] A(s,s);
for (int i = 0; i < s; i++){
	for (int j = 0; j < s; j++){
		AField >> A(i,j);
	}
}
Xh uh,vh;

// interpolate the matrix on mesh points 
func xLeft = -1 + int((x+1)/dA)*dA;
func xRight = -1 + int(1 + (x+1)/dA)*dA;
func yLeft = -1 + int((y+1)/dA)*dA;
func yRight = -1 + int(1+(y+1)/dA)*dA;

func f = (1/dA^2) * (A(int((x+1)/dA),int((y+1)/dA))*(xRight-x)*(yRight-y) 
    + A(int(1+(x+1)/dA),int((y+1)/dA))*(x-xLeft)*(yRight-y)
    + A(int((x+1)/dA),int(1+(y+1)/dA))*(xRight-x)*(y-yLeft)
    + A(int(1+(x+1)/dA),int(1+(y+1)/dA))*(x-xLeft)*(y-yLeft));

problem darcy(uh,vh) = 
	int2d(Th)(f * (dx(uh)*dx(vh) + dy(uh)*dy(vh)))
	+ on(1,uh=1)
	+ on(3,uh=0);

darcy;

plot(Th,uh,nbiso=100,value=1,wait=1);

